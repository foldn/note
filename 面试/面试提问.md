1. 计算机网络

1. http1.0和http2.0的区别，优化点
2. http网络连接，如何实现通信，如何保证通信顺序
3. 为什么使用长连接，使用长连接的优点是什么，一次连接只能进行一个请求么，如果可以多个，通过什么实现，如何保证多个请求的返回体能够返回给对应的请求服务器

2. 操作系统

1. 还记得什么知识
2. 操作系统如何保证线程安全（同步机制）

1. 高并发情况下通过cas或者读写锁更优
2. cas原子操作：通过硬件原子操作实现

1. cas原子操作的ABA问题：我们修改的前提是V和E相等，有可能我们进行修改的过程中，V的值已经发生过变化，然后又变化回来了（A-B-A）

1. ABA问题的解决：通过对V新增一个版本号，根据版本号确定是否一致

3. 互斥机制：通过互斥锁、自旋锁（临界区是同一个时间只允许一个线程访问的系统资源，必须使用同步机制保护，例如文件系统）

1. 互斥锁（适用于临界区操作时间长）：同一时间只允许一个线程访问，其他线程访问，将其加到阻塞队列中，待当前线程执行完，开始执行阻塞队列头部线程
2. 自旋锁（适用于临界区操作时间短，多cpu环境）：当前资源被一个线程访问时，其他线程请求访问，不会被阻塞，而是通过循环访问当前资源，查看是否已被上一个线程释放

4. 内存屏障：通过内存屏障强制指定指令的执行顺序，由于多线程的环境，编译器可能会对指令进行重排序，因此通过内存屏障可以防止执行乱序执行
5. 优先继承协议：高优先级进程被低优先级进程阻塞，暂时提升低优先级进程的优先级，使其快速执行完成释放资源，然后恢复锁

3. 进程间通信：管道、消息队列、共享内存、信号量、套接字、信号等

1. 管道：数据单向流动，从父节点流动到子节点或者子节点到父节点，两者间有一个通信通道
2. 消息队列：消息队列间通过消息体内设置的标识符来进行通信
3. 共享内存：多个进程之间共享同一块内存，需要同步机制保护
4. 信号量：通过信号量控制进程对资源的访问权限，线程池使用的就是这种思想，主要是用于控制进程同步
	1. 如何实现：例如信号量为01，为0则允许访问，为1则不允许
	2. 如何实现多个线程同步：根据操作系统中的pv操作，设置信号量为大于1的值，每次申请资源则信号量-1，释放资源，则信号量+1,当信号量为0时，则说明现在没有可用资源
5. 套接字：一般用于网络通信，实现：tcp、ssl
6. 信号：一般用于关闭通知或者中断通知

7. 基础知识

8. hashMap底层
	1. 底层数据结构：数组+链表+红黑树。默认链表长度超过8时转化为红黑树。默认负载因子0.75。
		1. 数组通过哈希直接定位桶
		2. 链表解决哈希冲突
		3. 红黑树防止链表过长
	2. 扩容机制，初始容量16，扩容为翻倍。
		1. 容量为2的幂次方容量的原因是使用位运算更快
		2. 插入过程：根据存储数据的key计算哈希值，根据哈希值确认桶的位置，如果当前位置已经存在元素，存储值链表中，如果链表长度超过8，则转化为红黑树。如果元素数量超过阈值（负载因子*容量）进行扩容，
		3. 哈希冲突解决
			1. 哈希冲突解决
				1. 链表法：在相同位置时，使用链表存储元素，元素过长，则使用hash表存储元素
				2. 开放寻址法
					1. 再哈希：进行两次哈希取值
					2. 线性探测：在哈希去之上加上一个线性取数
					3. 平方探测：加上平方值
		4. 扩容的具体操作：
			1. 创建一个新数组
			2. 旧数据迁移至新数组（新位置=原位置或者原位置+旧容量），更新位置的计算方式：旧的索引值在二进制下高位如果为一，则索引值为旧索引值新增一个高位（原来容量为8-->421，现在16-->8421，低位不变，新增了一个高位）
9.  hashMap为线程不安全，ConcurrentHashMap为线程安全，如何实现：Java8通过cas以及synchronized实现
		1. 在对应桶位置为空时，通过cas原子操作，桶不为空时，通过synchronized锁定链表或者树的头节点，插入元素
		2. 为什么synchronized只锁定头节点：锁粒度最小化，这样可以保证不同桶节点的元素之间没有锁竞争
		3. java7的concurrentHashMap实现：通过对hashMap分段加锁实现，最多16个锁，缺陷在于一个段内可能会有多个桶存在
10. 常用排序算法-思想
	1. 快排
		1. 算法思想：在所有元素中，选取一个基准值，将所有元素分为左右两个序列，递归左右序列，使得每个子序列中基准值左边的元素小于基准值，右边的元素大于基准值
		2. 关键要点：
			1. 三数中取基准值：随机选取，或者左中右选中位数
			2. 每一次的操作我们只需满足左边小于基准值，右边大于基准值，左右区间的顺序我们并不关心
	2. 归并排序
		1. 算法思想：将所有元素递归的分为两半，将两个子数组合并到一个数组中（新增一个临时数组存储数据，结束后拷贝排序后的数据到原数组中），当数组长度为1时，数据自有序
	3. 堆排序
		1. 算法思想
11. mysql以及clickHouse的区别，实现原理，ck的数据库引擎

12. mysql的多个数据引擎，常见调优，常见索引，最左索引是什么

13. gc原理-常见内存处理方式
14. redis的集群处理，redis的分片，redis想要新增集群节点，会执行什么流程，redis的负载均衡如何实现，如何保证新的key-value进入新增的集群节点，redis的持久化分布，分布式调用redis如何保证两次请求不会重复
15. ng的负载均衡，算法具体如何实现，如何保证这个请求到指定的服务中
16. 哈希冲突的解决，除了散列表和在哈希，还有什么方式
17. mongdb的基本使用，实现原理
18. mq的使用，mq的消息堆积，mq的消息丢失
19. 除了dubbo和zk，还用过其他相关的类似服务么

20. dubbo的注册机制以及zk的注册机制
21. dubbo和zk一般用来做什么
22. 如果一个分布式服务突然关闭，在zk注册中心中对应的数据会删除么，如果会删除，通过什么方式，如果不会，为什么
23. zk在服务中启用流程是什么样的
24. zk除了用作服务注册还可以用做什么

25. nacos一般用作什么，apollo呢，两者的实现原理是什么
26. linux下的排查问题过程，cpu占用过高、内存溢出等

27. top命令中的cpu占用linux系统是如何计算的
28. 有哪些具体的生产调优过程，最后发现问题是什么，如何解决

29. rbac是什么，除了rbac，还了解别的权限管理么，这几种权限管理模型各有什么优缺点，适用场景是什么
30. 登陆注册日志落库流程是什么样的，日志数据为什么是这么生成的，为什么这么做，通过什么避免消息重复以及id重复
31. 对大数据量的数据，进行操作，有什么需要注意的地方，如果需要对这个表操作进行调优，应该怎么做，有哪些常用的sql调优方式，如何进行读写分离
32. 三方平台的标准化插件的开发流程是什么样的，开发完成后执行流程是什么样的，为什么要基于groovy脚本开发插件，如何避免groovy脚本执行非法操作
33. 如何实现三方平台的高并发处理
34. 数据采集平台的作用，为什么要开发这么一个系统，系统的实现原理是什么
35. bi报表为什么要划分pc端以及移动端，如何实现数据权限控制，在bi报表中，缓存优化体现在哪些方面
36. springcloud中的注册中心是哪一个
37. java中的服务治理通过什么